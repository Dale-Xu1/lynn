# Lynn

Lynn is a lexer and LALR(1) parser generator based on an EBNF grammar declaration language.
Lynn supports Go and TypeScript as compilation targets for the lexer and parser programs.
The generated parser outputs a parse tree that may be traversed using the generated visitor interface.
Since Lynn's parser is generated by itself, an example for how to use the visitor interface to generate an AST from the parse tree can be found in `ast.go`.

## Usage

The program expects a path to the grammar declaration file and a package name for the generated program.

```bash
Usage: lynn [flags] <path>
Arguments:
  <path>
    	The path to the input file
  -a	Log syntax tree and augmented grammar
  -l string
    	Output program language ("go" or "ts") (default "go")
  -o string
    	Output Go package name (defaults to name of input file, not used in TypeScript compilation)
```

## Features

In the grammar declaration file, the lexer is defined using `token` and `frag` statements that associate an identifier with a regular expression.
Token expressions may refer to fragments via identifiers.
Lynn will merge all token expressions into a DFA and compile it to a lexer program.

The parser is defined using `rule` statements, which describe the LALR(1) context-free grammar.
Aliases may be given to items in a concatenation (which result in generated methods on the parse tree that may be accessed when visiting the nodes).
Each production may also receive a label that describes the name of the visitor function called for a node generated by this production.
```
rule expr : l=expr "+" r=expr  #addExpr ;
```

Lynn performs basic grammar rewriting when a production contains left or right recursion to resolve precedence and associativity ambiguities (when a production is both left and right recursive).
The rewriting process only occurs if an explicit precedence level is assigned to a production, and multiple productions may be assigned the same precedence level.
Precedence statements must be listed in order of lowest to highest.

```
prec assign : right // Specifies right associativity
rule expr : l=expr "=" r=expr  #assignExpr %assign ;
```

Lynn also provides features to handle error recovery.
The generated lexer accepts an error handler that provides the input stream, allowing the user to read characters until a synchronization point is found.
In rule definitions, the `error` terminal may be used to describe synchronization patterns.
(If this terminal is accessed in the parse tree, it will return the token that caused the error).

```
rule stmt : error ";" ; // If an error occurs when parsing a statement, synchronize at the next semicolon
```

## Example

Here is the grammar that describes the Lynn grammar declaration language written using itself (found in `lynn.ln`):

```
rule grammar : stmt* ;
rule stmt
    : RULE       IDENTIFIER ":" expr ";"                 #ruleStmt
    | PRECEDENCE IDENTIFIER v=(":" a=(LEFT | RIGHT))?    #precedenceStmt
    | TOKEN      IDENTIFIER ":" expr s=("->" SKIP)? ";"  #tokenStmt
    | FRAGMENT   IDENTIFIER ":" expr ";"                 #fragmentStmt
    | error ";"
    ;

prec union  : left
prec label
prec concat : left
prec alias
prec quantifier
rule expr
    : l=expr "|" r=expr                        #unionExpr      %union
    | expr "#" IDENTIFIER p=("%" IDENTIFIER)?  #labelExpr      %label
    | l=expr r=expr                            #concatExpr     %concat
    | IDENTIFIER "=" expr                      #aliasExpr      %alias
    | expr op=("?" | "*" | "+")                #quantifierExpr %quantifier
    | "(" expr ")"                             #groupExpr
    | IDENTIFIER                               #identifierExpr
    | STRING                                   #stringExpr
    | CLASS                                    #classExpr
    | ERROR                                    #errorExpr
    | "."                                      #anyExpr
    ;

token WHITESPACE : [ \t\n\r]+ -> skip ;
token COMMENT    : "//" .* [\n\r\0] | "/*" ("*" [^/] | [^*])* "*/" -> skip ;

token RULE       : "rule" ;
token PRECEDENCE : "prec" ;
token TOKEN      : "token" ;
token FRAGMENT   : "frag" ;
token LEFT       : "left" ;
token RIGHT      : "right" ;
token ERROR      : "error" ;
token SKIP       : "skip" ;

token EQUAL      : "=" ;
token PLUS       : "+" ;
token STAR       : "*" ;
token QUESTION   : "?" ;
token DOT        : "." ;
token BAR        : "|" ;
token HASH       : "#" ;
token PERCENT    : "%" ;
token SEMI       : ";" ;
token COLON      : ":" ;
token L_PAREN    : "(" ;
token R_PAREN    : ")" ;
token ARROW      : "->" ;

token IDENTIFIER : LETTER (LETTER | DIGIT)* ;
token STRING     : "\"" ([^\\\n\r"] | ESCAPE)* "\"" ;
token CLASS      : "[" "^"? ([^\\\n\r\]] | ESCAPE)* "]" ;

frag DIGIT       : [0-9] ;
frag LETTER      : [a-zA-Z_] ;
frag HEX         : [0-9a-fA-F] ;
frag ESCAPE      : "\\" ([^\n\rxuU] | "x" HEX HEX | "u" HEX HEX HEX HEX | "U" HEX HEX HEX HEX HEX HEX HEX HEX) ;
```
