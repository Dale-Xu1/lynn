# Lynn

Lynn is a lexer and LALR(1) parser generator based on an EBNF grammar declaration language.
(Generated lexer and parser programs are written in Go.)
The generated parser outputs a parse tree that may be traversed using the generated visitor interface.
Since Lynn's parser is generated by itself, an example for how to use the visitor interface to generate an AST from the parse tree can be found in `ast.go`.

## Usage

The program expects a path to the grammar declaration file and a package name for the generated program.

```bash
go run main.go <grammar file> <output package>
```

## Features

In the grammar declaration file, the lexer is defined using `token` and `fragment` statements that associate an identifier with a regular expression.
Token expressions may refer to fragments via identifiers.
Lynn will merge all token expressions into a DFA and compile it to a lexer program.

The parser is defined using `rule` statements, which describe the LALR(1) context-free grammar.
Aliases may be given to items in a concatenation (which result in generated methods on the parse tree that may be accessed when visiting the nodes).
Each production may also receive a label that describes the name of the visitor function called for a node generated by this production. The label may also specify associativity if it is classified as an infix ambiguity.

```
rule expr : l=expr "+" r=expr  #addExpr
```

Lynn performs basic grammar rewriting when a production contains left or right recursion to resolve precedence and associativity ambiguities (when a production is both left and right recursive).
If unspecified, the disambiguation assumes left associativity.
This procedure assumes that rules are listed in lowest to highest precedence.

```
rule expr : l=expr "=" r=expr  #assignExpr right // Specifies right associativity
```

Lynn also provides features to handle error recovery.
The generated lexer accepts an error handler that provides the input stream, allowing the user to read characters until a synchronization point is found.
In rule definitions, the `error` terminal may be used to describe synchronization patterns.
(If this terminal is accessed in the parse tree, it will return the token that caused the error).

```
rule stmt : error ";" // If an error occurs when parsing a statement, synchronize at the next semicolon
```

## Example

Here is the grammar that describes the Lynn grammar declaration language written using itself (found in `lynn.ln`):

```
rule grammar : stmt* ;
rule stmt
    : RULE     IDENTIFIER ":" expr ";"                 #ruleStmt
    | TOKEN    IDENTIFIER ":" expr s=("->" SKIP)? ";"  #tokenStmt
    | FRAGMENT IDENTIFIER ":" expr ";"                 #fragmentStmt
    | error ";"
    ;

rule expr
    : l=expr "|" r=expr                      #unionExpr
    | expr "#" IDENTIFIER a=(LEFT | RIGHT)?  #labelExpr
    | l=expr r=expr                          #concatExpr
    | IDENTIFIER "=" expr                    #aliasExpr
    | expr op=("?" | "*" | "+")              #quantifierExpr
    | "(" expr ")"                           #groupExpr
    | IDENTIFIER                             #identifierExpr
    | STRING                                 #stringExpr
    | CLASS                                  #classExpr
    | ERROR                                  #errorExpr
    | "."                                    #anyExpr
    ;

token WHITESPACE : [ \t\n\r]+ -> skip ;
token COMMENT    : "//" .* [\n\r\0] | "/*" ("*" [^/] | [^*])* "*/" -> skip ;

token RULE       : "rule" ;
token TOKEN      : "token" ;
token FRAGMENT   : "fragment" ;
token LEFT       : "left" ;
token RIGHT      : "right" ;
token ERROR      : "error" ;
token SKIP       : "skip" ;

token EQUAL      : "=" ;
token PLUS       : "+" ;
token STAR       : "*" ;
token QUESTION   : "?" ;
token DOT        : "." ;
token BAR        : "|" ;
token HASH       : "#" ;
token SEMI       : ";" ;
token COLON      : ":" ;
token L_PAREN    : "(" ;
token R_PAREN    : ")" ;
token ARROW      : "->" ;

token IDENTIFIER : LETTER (LETTER | DIGIT)* ;
token STRING     : "\"" ([^\\\n\r"] | ESCAPE)* "\"" ;
token CLASS      : "[" "^"? ([^\\\n\r\]] | ESCAPE)* "]" ;

fragment DIGIT   : [0-9] ;
fragment LETTER  : [a-zA-Z_] ;
fragment ESCAPE  : "\\" . ;
```
