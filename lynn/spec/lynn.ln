rule grammar : stmt* || ;
rule stmt
    : RULE     IDENTIFIER ":" expr ";"                 #ruleStmt
    | TOKEN    IDENTIFIER ":" expr s=("->" SKIP)? ";"  #tokenStmt
    | FRAGMENT IDENTIFIER ":" expr ";"                 #fragmentStmt
    | error ";"
    ;

rule expr
    : l=expr "|" r=expr                      #unionExpr
    | expr "#" IDENTIFIER a=(LEFT | RIGHT)?  #labelExpr
    | l=expr r=expr                          #concatExpr
    | IDENTIFIER "=" expr                    #aliasExpr
    | expr op=("?" | "*" | "+")              #quantifierExpr
    | "(" expr ")"                           #groupExpr
    | IDENTIFIER                             #identifierExpr
    | STRING                                 #stringExpr
    | CLASS                                  #classExpr
    | ERROR                                  #errorExpr
    | "."                                    #anyExpr
    ;

token WHITESPACE : [ \t\n\r]+ -> skip ;
token COMMENT    : "//" .* [\n\r\0] | "/*" ("*" [^/] | [^*])* "*/" -> skip ;

token RULE       : "rule" ;
token TOKEN      : "token" ;
token FRAGMENT   : "fragment" ;
token LEFT       : "left" ;
token RIGHT      : "right" ;
token ERROR      : "error" ;
token SKIP       : "skip" ;

token EQUAL      : "=" ;
token PLUS       : "+" ;
token STAR       : "*" ;
token QUESTION   : "?" ;
token DOT        : "." ;
token BAR        : "|" ;
token HASH       : "#" ;
token SEMI       : ";" ;
token COLON      : ":" ;
token L_PAREN    : "(" ;
token R_PAREN    : ")" ;
token ARROW      : "->" ;

token IDENTIFIER : LETTER (LETTER | DIGIT)* ;
token STRING     : "\"" ([^\\\n\r"] | ESCAPE)* "\"" ;
token CLASS      : "[" "^"? ([^\\\n\r\]] | ESCAPE)* "]" ;

fragment DIGIT   : [0-9] ;
fragment LETTER  : [a-zA-Z_] ;
fragment ESCAPE  : "\\" . ;
