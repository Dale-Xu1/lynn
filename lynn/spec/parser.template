package /*{0}*/

import (
	"fmt"
	"strings"
)

// Production data struct. Expresses a sequence of symbols that a given non-terminal may be expanded to in a grammar.
type productionData struct {
    productionType int
    left, length   int
    visitor        string
    aliases        map[string]int
}
// Parse table action entry struct. Holds action type and integer parameter.
type actionEntry struct {
    actionType, value int // For 0 actions, value represents a state identifier, for 1 actions, a production identifier
}

// Parse tree child interface. May either be a Token or ParseTreeNode struct.
type ParseTreeChild interface { string(indent string) string }
type ParseTreeNode struct {
    data     *productionData
    Children []ParseTreeChild
}

var productions = []productionData {
/*{1}*/
}
var actionTable = []map[TokenType]actionEntry {
/*{2}*/
}
var gotoTable = []map[int]int {
/*{3}*/
}

// Parser struct. Converts token stream to parse tree.
type Parser struct {
    lexer   *Lexer
    handler ParserErrorHandler
}

// Base visitor struct. Describes functions necessary to implement to traverse parse tree.
type BaseVisitor[T any] interface {
/*{4}*/
}

// Function called when the parser encounters an error.
type ParserErrorHandler func (token Token)
var DEFAULT_PARSER_HANDLER = func (token Token) {
    fmt.Printf("Syntax error: Unexpected token %q - %d:%d\n", token.Value, token.Start.Line, token.Start.Col)
}

// Returns new parser struct.
func NewParser(lexer *Lexer, handler ParserErrorHandler) *Parser { return &Parser { lexer, handler } }
// Generates parse tree based on token stream from lexer.
func (p *Parser) Parse() *ParseTreeNode {
    // Stack state struct. Holds the state identifier and the corresponding parse tree node.
    type StackState struct {
        state int
        node  ParseTreeChild
    }
    // Initialize current token and stack
    token, stack := p.lexer.Token, []StackState { { 0, nil } }
    for {
        // Get the current state at the top of the stack and find the action to take
        // Next action is determined by action table given state index and the current token type
        state := stack[len(stack) - 1].state
        action, ok := actionTable[state][token.Type]
        if !ok {
            // If the table does not have a valid action, cannot parse current token
            fmt.Printf("Syntax error: Unexpected token %q - %d:%d\n", token.Value, token.Start.Line, token.Start.Col)
            return nil
        }
        switch action.actionType {
        case 0:
            // For shift actions, add new state to the stack along with token
            stack = append(stack, StackState { action.value, token })
            token = p.lexer.Next()
        case 1:
            // For reduce actions, pop states off stack and merge children into one node based on production
            production := &productions[action.value]
            i := len(stack) - production.length
            var node ParseTreeChild
            switch production.productionType {
            case 0:
                // Handle normal productions
                // Collect child nodes from current states on the stack and create node for reduction
                children := make([]ParseTreeChild, production.length)
                for i, s := range stack[i:] { children[i] = s.node }
                node = &ParseTreeNode { production, children }
            case 2:
                // Handle flatten productions
                // Of the two nodes popped, preserve the first and add the second as a child of the first
                // Results in quantified expressions in the grammar generating arrays of elements
                list, element := stack[i].node.(*ParseTreeNode), stack[i + 1].node
                list.Children = append(list.Children, element)
                node = list
            case 1: node = stack[i].node // For auxiliary productions, pass child through without generating new node
            case 3: node = nil // Add nil value for removed productions
            }
            // Pop consumed states off stack
            // Given new state at the top of the stack, find next state based on the goto table
            stack = stack[:i]
            state := stack[i - 1].state
            next := gotoTable[state][production.left]
            // Add new state to top of the stack
            stack = append(stack, StackState { next, node })
        // Return non-terminal in auxiliary start production on accept
        case 2: return stack[1].node.(*ParseTreeNode)
        }
    }
}

// Given a parse tree node, dispatches the corresponding function in the visitor.
func VisitNode[T any](visitor BaseVisitor[T], node ParseTreeChild) T {
    if n, ok := node.(*ParseTreeNode); ok {
        switch n.data.visitor {
/*{5}*/
        }
    }
    panic("Invalid parse tree child passed to VisitNode()")
}

/*{6}*/

// Given an alias, return the corresponding parse tree node child based on the production data.
func (n *ParseTreeNode) GetAlias(alias string) ParseTreeChild {
    if n.data.aliases == nil { return nil }
    if i, ok := n.data.aliases[alias]; ok { return n.Children[i] }
    return nil
}

// FOR DEBUG PURPOSES:
// Prints the parse tree to the standard output.
func (n *ParseTreeNode) Print() { fmt.Println(n.string("")) }

func (t Token) string(indent string) string { return fmt.Sprintf("%s<%s %s>", indent, t.Type, t.Value) }
func (n *ParseTreeNode) string(indent string) string {
    children := make([]string, len(n.Children))
    next := indent + "  "
    for i, c := range n.Children {
        str := "\n"
        if c == nil {
            str += fmt.Sprintf("%s<nil>", next)
        } else {
            str += c.string(next)
        }
        children[i] = str
    }
    return fmt.Sprintf("%s[%s]%s", indent, n.data.visitor, strings.Join(children, ""))
}
